[[query-match]]
Match
=====

Pattern matching is one of the pillars of Cypher. The pattern is used to describe the shape of the data that we are
looking for. Cypher will then try to find patterns in the graph - these are called matching sub graphs.

The description of the pattern is made up of one or more paths, separated by commas. A path is a sequence of nodes and
relationships that always start and end in nodes. An example path would be:
+`(a)-->(b)`

Paths can be of arbitrary length, and the same node may appear in multiple places in the path. Node identifiers can be
used with or without surrounding parenthesis. These two match clauses are semantically identical - the difference is
purely aesthetic.

+`MATCH (a)-->(b)`+

and 

+`MATCH a-->b`+


Patterns have bound points, or start points. They are the parts of the pattern that are already "bound" to a set of
graph nodes or relationships. All parts of the pattern must be directly or indirectly bound to a start point - a pattern
where parts of the pattern are not reachable from any start point will be rejected.

The optional relationship is a way to describe parts of the pattern that can evaluate to null if it can not be
matched to the graph. It's the equivalent of SQL outer join - if Cypher finds one or more matches, they will be
returned. If no matches are found, Cypher will return a null. Only relationships can be marked as optional, and it's
done with a question mark.

Optional relationships of the pattern are used to answer queries like this:

[source,cypher]
----
START me=node(0)
MATCH me-->friend-[?:parent_of]->children
RETURN friend, children
----

The query above says "give me all my friends, and their children, if they have any."

Optionality travels - if a part of the pattern can only be reached from a bound point through an optional relationship,
that part is also optional. In the pattern above, the only bound point in the pattern is `me`. Since the relationship
between friend and children is optional, children is an optional part of the graph.

Also, named paths that contain optional parts are also optional - if any part of the path is
null, the whole path is null.

In these example, b and p are all optional and can contain null:

[source,cypher]
----
START a=node(1)
MATCH p = a-[?]->b
----

[source,cypher]
----
START a=node(1)
MATCH p = a-[*?]->b
----

[source,cypher]
----
START a=node(1)
MATCH p = a-[?]->x-->b
----

[source,cypher]
----
START a=node(1), x=node(100)
MATCH p = shortestPath( a-[*?]->x )
----



include::cypher-match-graph.txt[]

include::related-nodes.txt[]
include::outgoing-relationships.txt[]
include::directed-relationships-and-identifier.txt[]
include::match-by-relationship-type.txt[]
include::match-by-relationship-type-and-use-an-identifier.txt[]
include::relationship-types-with-uncommon-characters.txt[]
include::multiple-relationships.txt[]
include::variable-length-relationships.txt[]
include::relationship-identifier-in-variable-length-relationships.txt[]
include::zero-length-paths.txt[]
include::optional-relationship.txt[]
include::optional-typed-and-named-relationship.txt[]
include::properties-on-optional-elements.txt[]
include::complex-matching.txt[]
include::shortest-path.txt[]
include::all-shortest-paths.txt[]
include::named-path.txt[]
include::matching-on-a-bound-relationship.txt[]